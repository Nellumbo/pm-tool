const express = require('express');
const cors = require('cors');
const bodyParser = require('body-parser');
const path = require('path');
const { v4: uuidv4 } = require('uuid');
const moment = require('moment');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');
const Database = require('./database');

// Загружаем переменные окружения
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 5000;

// КРИТИЧНО: JWT_SECRET должен быть установлен в .env
if (!process.env.JWT_SECRET && process.env.NODE_ENV === 'production') {
  console.error('FATAL ERROR: JWT_SECRET is not defined in environment variables!');
  process.exit(1);
}
const JWT_SECRET = process.env.JWT_SECRET || 'demo-secret-key-FOR-DEVELOPMENT-ONLY';

// Middleware
app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

// Раздача статических файлов React приложения
if (process.env.NODE_ENV === 'production') {
  app.use(express.static(path.join(__dirname, '../client/build')));
}

// Middleware для проверки JWT токена
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN

  if (!token) {
    return res.status(401).json({ message: 'Токен доступа отсутствует' });
  }

  jwt.verify(token, JWT_SECRET, (err, user) => {
    if (err) {
      return res.status(403).json({ message: 'Недействительный токен' });
    }
    req.user = user;
    next();
  });
};

// Middleware для проверки ролей
const checkRole = (allowedRoles) => {
  return (req, res, next) => {
    // Проверяем роль из JWT токена
    if (!req.user) {
      return res.status(401).json({ message: 'Требуется аутентификация' });
    }

    if (allowedRoles.includes(req.user.role)) {
      next();
    } else {
      res.status(403).json({ message: 'Недостаточно прав для выполнения операции' });
    }
  };
};

// Middleware для логирования действий
const logAction = (action) => {
  return (req, res, next) => {
    const timestamp = moment().format('YYYY-MM-DD HH:mm:ss');
    const userName = req.user ? req.user.name : 'Неавторизован';
    const userRole = req.user ? req.user.role : 'unknown';
    console.log(`[${timestamp}] ${userName} (${userRole}): ${action} - ${req.method} ${req.path}`);
    next();
  };
};

// Инициализация базы данных
const db = new Database();
let dbInitialized = false;

// Инициализируем БД при старте
db.init()
  .then(() => {
    dbInitialized = true;
    console.log('База данных успешно инициализирована');
  })
  .catch((error) => {
    console.error('Ошибка инициализации базы данных:', error);
    process.exit(1);
  });

// Все данные теперь хранятся в SQLite БД (см. database.js)
// Тестовые данные создаются автоматически при первом запуске

// Аутентификация
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    title: 'Настройка инфраструктуры',
    description: 'Настройка сервера разработки, установка зависимостей и настройка CI/CD',
    priority: 'high',
    status: 'completed',
    projectId: '1',
    assigneeId: '1', // Администратор
    dueDate: moment().subtract(25, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(30, 'days').format(),
    updatedAt: moment().subtract(25, 'days').format()
  },
  {
    id: '2',
    title: 'Создание дизайн-системы',
    description: 'Разработка UI/UX дизайна, создание компонентной библиотеки',
    priority: 'high',
    status: 'in-progress',
    projectId: '1',
    assigneeId: '3', // Разработчик
    dueDate: moment().add(10, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(28, 'days').format(),
    updatedAt: moment().subtract(2, 'days').format()
  },
  {
    id: '3',
    title: 'API для аутентификации',
    description: 'Реализация JWT аутентификации, регистрация и авторизация пользователей',
    priority: 'high',
    status: 'completed',
    projectId: '1',
    assigneeId: '3', // Разработчик
    dueDate: moment().subtract(20, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(25, 'days').format(),
    updatedAt: moment().subtract(20, 'days').format()
  },
  {
    id: '4',
    title: 'Frontend компоненты',
    description: 'Создание основных React компонентов для интерфейса',
    priority: 'medium',
    status: 'in-progress',
    projectId: '1',
    assigneeId: '3', // Разработчик
    dueDate: moment().add(15, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(20, 'days').format(),
    updatedAt: moment().subtract(1, 'days').format()
  },
  {
    id: '5',
    title: 'Интеграционные тесты',
    description: 'Написание и запуск интеграционных тестов для API',
    priority: 'medium',
    status: 'todo',
    projectId: '1',
    assigneeId: '4', // Тестировщик
    dueDate: moment().add(20, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(15, 'days').format(),
    updatedAt: moment().subtract(15, 'days').format()
  },
  
  // Задачи для проекта "Мобильное приложение"
  {
    id: '6',
    title: 'Архитектура приложения',
    description: 'Проектирование архитектуры мобильного приложения, выбор технологий',
    priority: 'high',
    status: 'completed',
    projectId: '2',
    assigneeId: '3', // Разработчик
    dueDate: moment().subtract(10, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(15, 'days').format(),
    updatedAt: moment().subtract(10, 'days').format()
  },
  {
    id: '7',
    title: 'UI/UX дизайн мобильного приложения',
    description: 'Создание дизайна экранов и пользовательских сценариев',
    priority: 'medium',
    status: 'in-progress',
    projectId: '2',
    assigneeId: '3', // Разработчик
    dueDate: moment().add(25, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(12, 'days').format(),
    updatedAt: moment().subtract(1, 'days').format()
  },
  {
    id: '8',
    title: 'Настройка синхронизации данных',
    description: 'Реализация синхронизации между мобильным приложением и сервером',
    priority: 'high',
    status: 'todo',
    projectId: '2',
    assigneeId: '3', // Разработчик
    dueDate: moment().add(40, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(8, 'days').format(),
    updatedAt: moment().subtract(8, 'days').format()
  },
  
  // Задачи для завершенного проекта "Система аналитики"
  {
    id: '9',
    title: 'Исследование требований',
    description: 'Анализ бизнес-требований и выбор инструментов аналитики',
    priority: 'high',
    status: 'completed',
    projectId: '3',
    assigneeId: '2', // Менеджер проектов
    dueDate: moment().subtract(40, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(45, 'days').format(),
    updatedAt: moment().subtract(40, 'days').format()
  },
  {
    id: '10',
    title: 'Внедрение Google Analytics',
    description: 'Настройка и интеграция Google Analytics для отслеживания метрик',
    priority: 'medium',
    status: 'completed',
    projectId: '3',
    assigneeId: '3', // Разработчик
    dueDate: moment().subtract(20, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(35, 'days').format(),
    updatedAt: moment().subtract(20, 'days').format()
  },
  {
    id: '11',
    title: 'Создание дашборда отчетов',
    description: 'Разработка дашборда для визуализации аналитических данных',
    priority: 'high',
    status: 'completed',
    projectId: '3',
    assigneeId: '3', // Разработчик
    dueDate: moment().subtract(10, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(25, 'days').format(),
    updatedAt: moment().subtract(10, 'days').format()
  },
  {
    id: '12',
    title: 'Тестирование системы аналитики',
    description: 'Комплексное тестирование всех компонентов системы аналитики',
    priority: 'medium',
    status: 'completed',
    projectId: '3',
    assigneeId: '4', // Тестировщик
    dueDate: moment().subtract(5, 'days').format('YYYY-MM-DD'),
    createdAt: moment().subtract(15, 'days').format(),
    updatedAt: moment().subtract(5, 'days').format()
  }
];

// Добавляем тестовые комментарии
comments = [
  {
    id: '1',
    taskId: '2',
    content: 'Начал работу над дизайн-системой. Создал базовые компоненты кнопок и форм.',
    authorId: '3', // Разработчик
    createdAt: moment().subtract(5, 'days').format(),
    updatedAt: moment().subtract(5, 'days').format()
  },
  {
    id: '2',
    taskId: '2',
    content: 'Нужно добавить поддержку темной темы в дизайн-систему.',
    authorId: '1', // Администратор
    createdAt: moment().subtract(3, 'days').format(),
    updatedAt: moment().subtract(3, 'days').format()
  },
  {
    id: '3',
    taskId: '4',
    content: 'Создал основные компоненты: Header, Sidebar, Modal. Осталось доделать таблицы.',
    authorId: '3', // Разработчик
    createdAt: moment().subtract(1, 'days').format(),
    updatedAt: moment().subtract(1, 'days').format()
  },
  {
    id: '4',
    taskId: '7',
    content: 'Дизайн экранов готов. Жду фидбека от заказчика.',
    authorId: '3', // Разработчик
    createdAt: moment().subtract(2, 'days').format(),
    updatedAt: moment().subtract(2, 'days').format()
  },
  {
    id: '5',
    taskId: '5',
    content: 'Начну писать тесты на следующей неделе.',
    authorId: '4', // Тестировщик
    createdAt: moment().subtract(1, 'days').format(),
    updatedAt: moment().subtract(1, 'days').format()
  }
];

// Хешируем пароли для демонстрации (в реальном приложении это делается при регистрации)
const hashPassword = async (password) => {
  return await bcrypt.hash(password, 10);
};

// Создаем пользователей с хешированными паролями
let users = [
  {
    id: '1',
    name: 'Администратор',
    email: 'admin@example.com',
    password: '$2b$10$FNd6iKn/Yxq7UtatAgTaZuHg3QIfnt1u6b/JL9KfNyVIWV3/nrywC', // admin123
    role: 'admin',
    department: 'Управление',
    position: 'Администратор системы'
  },
  {
    id: '2',
    name: 'Менеджер проектов',
    email: 'manager@example.com',
    password: '$2b$10$KXP9dDOxT6CHhsMq6phOvuSSDTFMR7zN3jYv3XD3S6Pexgdmew6Dm', // manager123
    role: 'manager',
    department: 'Управление проектами',
    position: 'Менеджер проектов'
  },
  {
    id: '3',
    name: 'Разработчик',
    email: 'developer@example.com',
    password: '$2b$10$XRXiMM8Zbdyl2D2cNQA9N.RSw9oDnXeGM9Rm6VTB1IgNO8GLSM3Oe', // dev123
    role: 'developer',
    department: 'Разработка',
    position: 'Разработчик'
  },
  {
    id: '4',
    name: 'Тестировщик',
    email: 'tester@example.com',
    password: '$2b$10$RlGL.6MIvap1eRQJPesfbOYv4fgSIlUUJyLqVWKeY9lwychCTmf.q', // test123
    role: 'developer',
    department: 'QA',
    position: 'Тестировщик'
  }
];
let templates = [
  {
    id: '1',
    name: 'Разработка функционала',
    description: 'Создание новой функциональности',
    priority: 'high',
    category: 'development'
  },
  {
    id: '2',
    name: 'Исправление ошибки',
    description: 'Исправление бага в системе',
    priority: 'high',
    category: 'bugfix'
  },
  {
    id: '3',
    name: 'Тестирование',
    description: 'Проведение тестирования функционала',
    priority: 'medium',
    category: 'testing'
  },
  {
    id: '4',
    name: 'Документация',
    description: 'Создание или обновление документации',
    priority: 'low',
    category: 'documentation'
  },
  {
    id: '5',
    name: 'Встреча с клиентом',
    description: 'Проведение встречи с заказчиком',
    priority: 'medium',
    category: 'meeting'
  }
];

// Аутентификация
app.post('/api/auth/login', async (req, res) => {
  try {
    const { email, password } = req.body;

    // Находим пользователя в БД
    const user = await db.get('SELECT * FROM users WHERE email = ?', [email]);
    if (!user) {
      return res.status(401).json({ message: 'Неверный email или пароль' });
    }

    // Проверяем пароль
    const validPassword = await bcrypt.compare(password, user.password);
    if (!validPassword) {
      return res.status(401).json({ message: 'Неверный email или пароль' });
    }

    // Создаем JWT токен
    const token = jwt.sign(
      {
        id: user.id,
        email: user.email,
        role: user.role,
        name: user.name
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    // Возвращаем пользователя без пароля
    const { password: _, ...userWithoutPassword } = user;
    res.json({
      token,
      user: userWithoutPassword
    });
  } catch (error) {
    console.error('Ошибка входа:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.post('/api/auth/register', async (req, res) => {
  try {
    const { name, email, password, role = 'developer', department, position } = req.body;

    // Проверяем, существует ли пользователь в БД
    const existingUser = await db.get('SELECT * FROM users WHERE email = ?', [email]);
    if (existingUser) {
      return res.status(400).json({ message: 'Пользователь с таким email уже существует' });
    }

    // Хешируем пароль
    const hashedPassword = await hashPassword(password);

    // Создаем пользователя в БД
    const userId = uuidv4();
    await db.run(
      'INSERT INTO users (id, name, email, password, role, department, position) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [userId, name, email, hashedPassword, role, department, position]
    );

    // Получаем созданного пользователя
    const newUser = await db.get('SELECT * FROM users WHERE id = ?', [userId]);

    // Создаем JWT токен
    const token = jwt.sign(
      {
        id: newUser.id,
        email: newUser.email,
        role: newUser.role,
        name: newUser.name
      },
      JWT_SECRET,
      { expiresIn: '24h' }
    );

    // Возвращаем пользователя без пароля
    const { password: _, ...userWithoutPassword } = newUser;
    res.json({
      token,
      user: userWithoutPassword
    });
  } catch (error) {
    console.error('Ошибка регистрации:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.post('/api/auth/verify', authenticateToken, (req, res) => {
  res.json({ user: req.user });
});

// Routes для пользователей
app.get('/api/users', authenticateToken, checkRole(['admin', 'manager']), async (req, res) => {
  try {
    // Получаем всех пользователей из БД
    const users = await db.all('SELECT id, name, email, role, department, position, createdAt, updatedAt FROM users');
    res.json(users);
  } catch (error) {
    console.error('Ошибка получения пользователей:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.post('/api/users', authenticateToken, checkRole(['admin']), logAction('Создание пользователя'), async (req, res) => {
  try {
    const { name, email, password = 'changeme123', role = 'developer', department, position } = req.body;

    // Проверяем, существует ли пользователь
    const existingUser = await db.get('SELECT * FROM users WHERE email = ?', [email]);
    if (existingUser) {
      return res.status(400).json({ message: 'Пользователь с таким email уже существует' });
    }

    // Хешируем пароль
    const hashedPassword = await bcrypt.hash(password, 10);

    // Создаем пользователя в БД
    const userId = uuidv4();
    await db.run(
      'INSERT INTO users (id, name, email, password, role, department, position) VALUES (?, ?, ?, ?, ?, ?, ?)',
      [userId, name, email, hashedPassword, role, department, position]
    );

    // Получаем созданного пользователя (без пароля)
    const newUser = await db.get(
      'SELECT id, name, email, role, department, position, createdAt, updatedAt FROM users WHERE id = ?',
      [userId]
    );

    res.json(newUser);
  } catch (error) {
    console.error('Ошибка создания пользователя:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.put('/api/users/:id', authenticateToken, checkRole(['admin']), logAction('Обновление пользователя'), async (req, res) => {
  try {
    const { name, email, role, department, position } = req.body;

    // Проверяем существование пользователя
    const user = await db.get('SELECT * FROM users WHERE id = ?', [req.params.id]);
    if (!user) {
      return res.status(404).json({ message: 'Пользователь не найден' });
    }

    // Обновляем пользователя
    await db.run(
      'UPDATE users SET name = ?, email = ?, role = ?, department = ?, position = ?, updatedAt = CURRENT_TIMESTAMP WHERE id = ?',
      [name || user.name, email || user.email, role || user.role, department || user.department, position || user.position, req.params.id]
    );

    // Получаем обновленного пользователя (без пароля)
    const updatedUser = await db.get(
      'SELECT id, name, email, role, department, position, createdAt, updatedAt FROM users WHERE id = ?',
      [req.params.id]
    );

    res.json(updatedUser);
  } catch (error) {
    console.error('Ошибка обновления пользователя:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.delete('/api/users/:id', authenticateToken, checkRole(['admin']), logAction('Удаление пользователя'), async (req, res) => {
  try {
    // Проверяем существование пользователя
    const user = await db.get('SELECT * FROM users WHERE id = ?', [req.params.id]);
    if (!user) {
      return res.status(404).json({ message: 'Пользователь не найден' });
    }

    // Удаляем пользователя
    await db.run('DELETE FROM users WHERE id = ?', [req.params.id]);

    res.json({ message: 'Пользователь удален' });
  } catch (error) {
    console.error('Ошибка удаления пользователя:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

// Шаблоны задач
app.get('/api/templates', authenticateToken, async (req, res) => {
  try {
    const templates = await db.all('SELECT * FROM templates ORDER BY name');
    res.json(templates);
  } catch (error) {
    console.error('Ошибка получения шаблонов:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.post('/api/templates', authenticateToken, checkRole(['admin', 'manager']), async (req, res) => {
  try {
    const { name, description, priority = 'medium', estimatedHours } = req.body;

    const templateId = uuidv4();
    await db.run(
      'INSERT INTO templates (id, name, description, priority, estimatedHours) VALUES (?, ?, ?, ?, ?)',
      [templateId, name, description, priority, estimatedHours]
    );

    const newTemplate = await db.get('SELECT * FROM templates WHERE id = ?', [templateId]);
    res.json(newTemplate);
  } catch (error) {
    console.error('Ошибка создания шаблона:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.put('/api/templates/:id', authenticateToken, checkRole(['admin', 'manager']), async (req, res) => {
  try {
    const { name, description, priority, estimatedHours } = req.body;

    const template = await db.get('SELECT * FROM templates WHERE id = ?', [req.params.id]);
    if (!template) {
      return res.status(404).json({ message: 'Шаблон не найден' });
    }

    await db.run(
      'UPDATE templates SET name = ?, description = ?, priority = ?, estimatedHours = ? WHERE id = ?',
      [
        name || template.name,
        description !== undefined ? description : template.description,
        priority || template.priority,
        estimatedHours !== undefined ? estimatedHours : template.estimatedHours,
        req.params.id
      ]
    );

    const updatedTemplate = await db.get('SELECT * FROM templates WHERE id = ?', [req.params.id]);
    res.json(updatedTemplate);
  } catch (error) {
    console.error('Ошибка обновления шаблона:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.delete('/api/templates/:id', authenticateToken, checkRole(['admin', 'manager']), async (req, res) => {
  try {
    const template = await db.get('SELECT * FROM templates WHERE id = ?', [req.params.id]);
    if (!template) {
      return res.status(404).json({ message: 'Шаблон не найден' });
    }

    await db.run('DELETE FROM templates WHERE id = ?', [req.params.id]);

    res.json({ message: 'Шаблон удален' });
  } catch (error) {
    console.error('Ошибка удаления шаблона:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

// Комментарии к задачам
app.get('/api/tasks/:taskId/comments', authenticateToken, async (req, res) => {
  try {
    const comments = await db.all('SELECT * FROM comments WHERE taskId = ? ORDER BY createdAt ASC', [req.params.taskId]);
    res.json(comments);
  } catch (error) {
    console.error('Ошибка получения комментариев:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.post('/api/tasks/:taskId/comments', authenticateToken, async (req, res) => {
  try {
    const { content } = req.body;
    const userId = req.user.id; // Берем из JWT токена

    const commentId = uuidv4();
    await db.run(
      'INSERT INTO comments (id, taskId, userId, text) VALUES (?, ?, ?, ?)',
      [commentId, req.params.taskId, userId, content]
    );

    const newComment = await db.get('SELECT * FROM comments WHERE id = ?', [commentId]);
    res.json(newComment);
  } catch (error) {
    console.error('Ошибка создания комментария:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.put('/api/comments/:id', authenticateToken, async (req, res) => {
  try {
    const { content } = req.body;

    const comment = await db.get('SELECT * FROM comments WHERE id = ?', [req.params.id]);
    if (!comment) {
      return res.status(404).json({ message: 'Комментарий не найден' });
    }

    // Проверяем, что пользователь может редактировать только свои комментарии
    if (comment.userId !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Нет прав для редактирования этого комментария' });
    }

    await db.run(
      'UPDATE comments SET text = ? WHERE id = ?',
      [content, req.params.id]
    );

    const updatedComment = await db.get('SELECT * FROM comments WHERE id = ?', [req.params.id]);
    res.json(updatedComment);
  } catch (error) {
    console.error('Ошибка обновления комментария:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.delete('/api/comments/:id', authenticateToken, async (req, res) => {
  try {
    const comment = await db.get('SELECT * FROM comments WHERE id = ?', [req.params.id]);
    if (!comment) {
      return res.status(404).json({ message: 'Комментарий не найден' });
    }

    // Проверяем, что пользователь может удалять только свои комментарии
    if (comment.userId !== req.user.id && req.user.role !== 'admin') {
      return res.status(403).json({ message: 'Нет прав для удаления этого комментария' });
    }

    await db.run('DELETE FROM comments WHERE id = ?', [req.params.id]);

    res.json({ message: 'Комментарий удален' });
  } catch (error) {
    console.error('Ошибка удаления комментария:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

// Routes для проектов
app.get('/api/projects', authenticateToken, checkRole(['admin', 'manager', 'developer']), async (req, res) => {
  try {
    const projects = await db.all('SELECT * FROM projects ORDER BY createdAt DESC');
    res.json(projects);
  } catch (error) {
    console.error('Ошибка получения проектов:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.get('/api/projects/:id', authenticateToken, checkRole(['admin', 'manager', 'developer']), async (req, res) => {
  try {
    const project = await db.get('SELECT * FROM projects WHERE id = ?', [req.params.id]);
    if (!project) {
      return res.status(404).json({ message: 'Проект не найден' });
    }
    res.json(project);
  } catch (error) {
    console.error('Ошибка получения проекта:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.post('/api/projects', authenticateToken, checkRole(['admin', 'manager']), logAction('Создание проекта'), async (req, res) => {
  try {
    const { name, description, startDate, endDate, status = 'active', managerId } = req.body;

    const projectId = uuidv4();
    await db.run(
      'INSERT INTO projects (id, name, description, startDate, endDate, status, managerId, progress) VALUES (?, ?, ?, ?, ?, ?, ?, ?)',
      [projectId, name, description, startDate, endDate, status, managerId, 0]
    );

    const newProject = await db.get('SELECT * FROM projects WHERE id = ?', [projectId]);
    res.json(newProject);
  } catch (error) {
    console.error('Ошибка создания проекта:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.put('/api/projects/:id', authenticateToken, checkRole(['admin', 'manager']), logAction('Обновление проекта'), async (req, res) => {
  try {
    const { name, description, startDate, endDate, status, managerId, progress } = req.body;

    const project = await db.get('SELECT * FROM projects WHERE id = ?', [req.params.id]);
    if (!project) {
      return res.status(404).json({ message: 'Проект не найден' });
    }

    await db.run(
      'UPDATE projects SET name = ?, description = ?, startDate = ?, endDate = ?, status = ?, managerId = ?, progress = ?, updatedAt = CURRENT_TIMESTAMP WHERE id = ?',
      [
        name || project.name,
        description !== undefined ? description : project.description,
        startDate || project.startDate,
        endDate || project.endDate,
        status || project.status,
        managerId || project.managerId,
        progress !== undefined ? progress : project.progress,
        req.params.id
      ]
    );

    const updatedProject = await db.get('SELECT * FROM projects WHERE id = ?', [req.params.id]);
    res.json(updatedProject);
  } catch (error) {
    console.error('Ошибка обновления проекта:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.delete('/api/projects/:id', authenticateToken, checkRole(['admin']), logAction('Удаление проекта'), async (req, res) => {
  try {
    const project = await db.get('SELECT * FROM projects WHERE id = ?', [req.params.id]);
    if (!project) {
      return res.status(404).json({ message: 'Проект не найден' });
    }

    // Удаляем все задачи проекта
    await db.run('DELETE FROM tasks WHERE projectId = ?', [req.params.id]);

    // Удаляем проект
    await db.run('DELETE FROM projects WHERE id = ?', [req.params.id]);

    res.json({ message: 'Проект удален' });
  } catch (error) {
    console.error('Ошибка удаления проекта:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

// Routes для задач
app.get('/api/tasks', authenticateToken, async (req, res) => {
  try {
    const { projectId } = req.query;

    let query = 'SELECT * FROM tasks ORDER BY createdAt DESC';
    let params = [];

    if (projectId) {
      query = 'SELECT * FROM tasks WHERE projectId = ? ORDER BY createdAt DESC';
      params = [projectId];
    }

    const tasks = await db.all(query, params);
    res.json(tasks);
  } catch (error) {
    console.error('Ошибка получения задач:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.get('/api/tasks/:id', authenticateToken, async (req, res) => {
  try {
    const task = await db.get('SELECT * FROM tasks WHERE id = ?', [req.params.id]);
    if (!task) {
      return res.status(404).json({ message: 'Задача не найдена' });
    }
    res.json(task);
  } catch (error) {
    console.error('Ошибка получения задачи:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.post('/api/tasks', authenticateToken, async (req, res) => {
  try {
    const { title, description, priority = 'medium', status = 'todo', projectId, assigneeId, dueDate, parentTaskId } = req.body;

    const taskId = uuidv4();
    await db.run(
      'INSERT INTO tasks (id, title, description, priority, status, projectId, assigneeId, dueDate, parentTaskId) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)',
      [taskId, title, description, priority, status, projectId, assigneeId, dueDate, parentTaskId]
    );

    const newTask = await db.get('SELECT * FROM tasks WHERE id = ?', [taskId]);
    res.json(newTask);
  } catch (error) {
    console.error('Ошибка создания задачи:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.put('/api/tasks/:id', authenticateToken, async (req, res) => {
  try {
    const { title, description, priority, status, projectId, assigneeId, dueDate, parentTaskId } = req.body;

    const task = await db.get('SELECT * FROM tasks WHERE id = ?', [req.params.id]);
    if (!task) {
      return res.status(404).json({ message: 'Задача не найдена' });
    }

    await db.run(
      'UPDATE tasks SET title = ?, description = ?, priority = ?, status = ?, projectId = ?, assigneeId = ?, dueDate = ?, parentTaskId = ?, updatedAt = CURRENT_TIMESTAMP WHERE id = ?',
      [
        title || task.title,
        description !== undefined ? description : task.description,
        priority || task.priority,
        status || task.status,
        projectId || task.projectId,
        assigneeId !== undefined ? assigneeId : task.assigneeId,
        dueDate !== undefined ? dueDate : task.dueDate,
        parentTaskId !== undefined ? parentTaskId : task.parentTaskId,
        req.params.id
      ]
    );

    const updatedTask = await db.get('SELECT * FROM tasks WHERE id = ?', [req.params.id]);
    res.json(updatedTask);
  } catch (error) {
    console.error('Ошибка обновления задачи:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

// Обновление статуса задачи (для Kanban)
app.patch('/api/tasks/:id/status', authenticateToken, async (req, res) => {
  try {
    const { status } = req.body;

    if (!['todo', 'in-progress', 'completed'].includes(status)) {
      return res.status(400).json({ message: 'Неверный статус' });
    }

    const task = await db.get('SELECT * FROM tasks WHERE id = ?', [req.params.id]);
    if (!task) {
      return res.status(404).json({ message: 'Задача не найдена' });
    }

    await db.run(
      'UPDATE tasks SET status = ?, updatedAt = CURRENT_TIMESTAMP WHERE id = ?',
      [status, req.params.id]
    );

    const updatedTask = await db.get('SELECT * FROM tasks WHERE id = ?', [req.params.id]);
    res.json(updatedTask);
  } catch (error) {
    console.error('Ошибка обновления статуса задачи:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.delete('/api/tasks/:id', authenticateToken, async (req, res) => {
  try {
    const task = await db.get('SELECT * FROM tasks WHERE id = ?', [req.params.id]);
    if (!task) {
      return res.status(404).json({ message: 'Задача не найдена' });
    }

    // Удаляем все подзадачи
    await db.run('DELETE FROM tasks WHERE parentTaskId = ?', [req.params.id]);

    // Удаляем задачу
    await db.run('DELETE FROM tasks WHERE id = ?', [req.params.id]);

    res.json({ message: 'Задача удалена' });
  } catch (error) {
    console.error('Ошибка удаления задачи:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

// Поиск
app.get('/api/search', authenticateToken, async (req, res) => {
  try {
    const { q: query, type } = req.query;

    if (!query || query.trim().length < 2) {
      return res.json({ projects: [], tasks: [] });
    }

    const searchTerm = `%${query.trim()}%`;

    let matchingProjects = [];
    let matchingTasks = [];

    if (!type || type === 'projects') {
      matchingProjects = await db.all(
        'SELECT * FROM projects WHERE name LIKE ? OR description LIKE ? ORDER BY createdAt DESC',
        [searchTerm, searchTerm]
      );
    }

    if (!type || type === 'tasks') {
      matchingTasks = await db.all(
        'SELECT * FROM tasks WHERE title LIKE ? OR description LIKE ? ORDER BY createdAt DESC',
        [searchTerm, searchTerm]
      );
    }

    res.json({ projects: matchingProjects, tasks: matchingTasks });
  } catch (error) {
    console.error('Ошибка поиска:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

// Просроченные задачи
app.get('/api/overdue-tasks', authenticateToken, async (req, res) => {
  try {
    const now = moment().format('YYYY-MM-DD');
    const overdueTasks = await db.all(
      'SELECT * FROM tasks WHERE dueDate < ? AND status != ? ORDER BY dueDate ASC',
      [now, 'completed']
    );

    res.json(overdueTasks);
  } catch (error) {
    console.error('Ошибка получения просроченных задач:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

// Задачи, истекающие сегодня
app.get('/api/today-tasks', authenticateToken, async (req, res) => {
  try {
    const today = moment().format('YYYY-MM-DD');
    const todayTasks = await db.all(
      'SELECT * FROM tasks WHERE dueDate = ? AND status != ? ORDER BY priority DESC',
      [today, 'completed']
    );

    res.json(todayTasks);
  } catch (error) {
    console.error('Ошибка получения задач на сегодня:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

// Экспорт данных
app.get('/api/export/projects', authenticateToken, async (req, res) => {
  try {
    const projects = await db.all('SELECT * FROM projects');
    const users = await db.all('SELECT id, name FROM users');

    const csvHeader = 'ID,Название,Описание,Статус,Дата начала,Дата окончания,Менеджер,Прогресс,Создан,Обновлен\n';
    const csvData = projects.map(project => {
      const manager = users.find(u => u.id === project.managerId);
      return [
        project.id,
        `"${project.name}"`,
        `"${(project.description || '').replace(/"/g, '""')}"`,
        project.status,
        project.startDate ? moment(project.startDate).format('DD.MM.YYYY') : '',
        project.endDate ? moment(project.endDate).format('DD.MM.YYYY') : '',
        manager ? `"${manager.name}"` : '',
        project.progress || 0,
        moment(project.createdAt).format('DD.MM.YYYY HH:mm'),
        moment(project.updatedAt).format('DD.MM.YYYY HH:mm')
      ].join(',');
    }).join('\n');

    const csv = csvHeader + csvData;

    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename=projects_${moment().format('YYYY-MM-DD')}.csv`);
    res.send('\ufeff' + csv); // BOM для правильного отображения кириллицы в Excel
  } catch (error) {
    console.error('Ошибка экспорта проектов:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.get('/api/export/tasks', authenticateToken, async (req, res) => {
  try {
    const tasks = await db.all('SELECT * FROM tasks');
    const projects = await db.all('SELECT id, name FROM projects');
    const users = await db.all('SELECT id, name FROM users');

    const csvHeader = 'ID,Название,Описание,Приоритет,Статус,Проект,Исполнитель,Срок,Создан,Обновлен\n';
    const csvData = tasks.map(task => {
      const project = projects.find(p => p.id === task.projectId);
      const assignee = users.find(u => u.id === task.assigneeId);
      return [
        task.id,
        `"${task.title}"`,
        `"${(task.description || '').replace(/"/g, '""')}"`,
        task.priority,
        task.status,
        project ? `"${project.name}"` : '',
        assignee ? `"${assignee.name}"` : '',
        task.dueDate ? moment(task.dueDate).format('DD.MM.YYYY') : '',
        moment(task.createdAt).format('DD.MM.YYYY HH:mm'),
        moment(task.updatedAt).format('DD.MM.YYYY HH:mm')
      ].join(',');
    }).join('\n');

    const csv = csvHeader + csvData;

    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename=tasks_${moment().format('YYYY-MM-DD')}.csv`);
    res.send('\ufeff' + csv); // BOM для правильного отображения кириллицы в Excel
  } catch (error) {
    console.error('Ошибка экспорта задач:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

app.get('/api/export/all', authenticateToken, async (req, res) => {
  try {
    const projects = await db.all('SELECT * FROM projects');
    const tasks = await db.all('SELECT * FROM tasks');
    const users = await db.all('SELECT id, name FROM users');

    const csvHeader = 'Тип,ID,Название,Описание,Статус,Приоритет,Проект,Исполнитель,Срок,Создан,Обновлен\n';

    // Добавляем проекты
    const projectsData = projects.map(project => {
      const manager = users.find(u => u.id === project.managerId);
      return [
        'Проект',
        project.id,
        `"${project.name}"`,
        `"${(project.description || '').replace(/"/g, '""')}"`,
        project.status,
        '',
        '',
        manager ? `"${manager.name}"` : '',
        project.endDate ? moment(project.endDate).format('DD.MM.YYYY') : '',
        moment(project.createdAt).format('DD.MM.YYYY HH:mm'),
        moment(project.updatedAt).format('DD.MM.YYYY HH:mm')
      ].join(',');
    });

    // Добавляем задачи
    const tasksData = tasks.map(task => {
      const project = projects.find(p => p.id === task.projectId);
      const assignee = users.find(u => u.id === task.assigneeId);
      return [
        'Задача',
        task.id,
        `"${task.title}"`,
        `"${(task.description || '').replace(/"/g, '""')}"`,
        task.status,
        task.priority,
        project ? `"${project.name}"` : '',
        assignee ? `"${assignee.name}"` : '',
        task.dueDate ? moment(task.dueDate).format('DD.MM.YYYY') : '',
        moment(task.createdAt).format('DD.MM.YYYY HH:mm'),
        moment(task.updatedAt).format('DD.MM.YYYY HH:mm')
      ].join(',');
    });

    const csv = csvHeader + projectsData.join('\n') + '\n' + tasksData.join('\n');

    res.setHeader('Content-Type', 'text/csv; charset=utf-8');
    res.setHeader('Content-Disposition', `attachment; filename=all_data_${moment().format('YYYY-MM-DD')}.csv`);
    res.send('\ufeff' + csv); // BOM для правильного отображения кириллицы в Excel
  } catch (error) {
    console.error('Ошибка экспорта данных:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

// Статистика
app.get('/api/stats', authenticateToken, async (req, res) => {
  try {
    // Статистика по проектам
    const totalProjects = await db.get('SELECT COUNT(*) as count FROM projects');
    const activeProjects = await db.get('SELECT COUNT(*) as count FROM projects WHERE status = ?', ['active']);
    const completedProjects = await db.get('SELECT COUNT(*) as count FROM projects WHERE status = ?', ['completed']);

    // Статистика по задачам
    const totalTasks = await db.get('SELECT COUNT(*) as count FROM tasks');
    const completedTasks = await db.get('SELECT COUNT(*) as count FROM tasks WHERE status = ?', ['completed']);
    const inProgressTasks = await db.get('SELECT COUNT(*) as count FROM tasks WHERE status = ?', ['in-progress']);
    const todoTasks = await db.get('SELECT COUNT(*) as count FROM tasks WHERE status = ?', ['todo']);

    res.json({
      projects: {
        total: totalProjects.count,
        active: activeProjects.count,
        completed: completedProjects.count
      },
      tasks: {
        total: totalTasks.count,
        completed: completedTasks.count,
        inProgress: inProgressTasks.count,
        todo: todoTasks.count
      }
    });
  } catch (error) {
    console.error('Ошибка получения статистики:', error);
    res.status(500).json({ message: 'Внутренняя ошибка сервера' });
  }
});

// Маршрут для React приложения (должен быть последним)
if (process.env.NODE_ENV === 'production') {
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, '../client/build', 'index.html'));
  });
}

app.listen(PORT, () => {
  console.log(`Сервер запущен на порту ${PORT}`);
});
